# Profile Versioning & Audit Trail Guide

## Overview

This document explains the profile versioning system that tracks configuration changes and links alerts to the exact profile version that generated them.

## Architecture

### Core Entities

**MonitoringProfile**
- `Version` (int): Incremented each time profile is modified (default: 1)
- `History` (navigation): Collection of all historical versions

**MonitoringProfileHistory**
- `Id`: Primary key
- `MonitoringProfileId`: Foreign key to profile
- `Version`: Version number (unique per profile)
- `ProfileSnapshot`: JSON serialized profile data (max 4000 chars)
- `ModifiedBy`: Username who made the change
- `CreatedAt`: Timestamp of version creation
- `ChangeNotes`: Optional description of changes
- `GeneratedAlerts`: Navigation to alerts created by this version

**MotionAlert**
- `ProfileHistoryId`: Links alert to specific profile version (nullable)
- `ProfileHistory`: Navigation property

### Indexes
- `MonitoringProfiles.Version` - Fast lookup by version
- `MonitoringProfileHistories.MonitoringProfileId` - Fast history queries
- `MonitoringProfileHistories.Version` - Fast version queries
- `MonitoringProfileHistories(MonitoringProfileId, Version)` - Unique constraint
- `MotionAlerts.ProfileHistoryId` - Fast alert-to-version queries

### Cascade Behavior
- Profile deleted → All history CASCADE deleted
- Profile deleted → Station CASCADE deleted → TimeFrames CASCADE deleted → Alerts SET NULL
- ProfileHistory deleted → Alerts SET NULL (preserve alert, lose version link)
- TimeFrame deleted → Alerts NO ACTION (prevent cascade cycle)

## Usage

### 1. Creating Profile Snapshot

```csharp
// Inject service
private readonly IProfileVersioningService _versioningService;

// Before updating profile
int historyId = await _versioningService.CreateProfileSnapshotAsync(
    profileId: 1,
    modifiedBy: "admin@company.com",
    changeNotes: "Updated morning shift time from 7:00 to 6:30"
);

// historyId can be used when manually creating alerts
```

### 2. Getting Profile History

```csharp
// Get all versions for audit UI
var history = await _versioningService.GetProfileHistoryAsync(profileId: 1);

foreach (var version in history)
{
    Console.WriteLine($"Version {version.Version}:");
    Console.WriteLine($"  Modified by: {version.ModifiedBy}");
    Console.WriteLine($"  At: {version.CreatedAt}");
    Console.WriteLine($"  Notes: {version.ChangeNotes}");
    Console.WriteLine($"  Snapshot: {version.ProfileSnapshot}");
}
```

### 3. Getting Specific Version

```csharp
// Get version 3 of profile 1
var version3 = await _versioningService.GetProfileVersionAsync(
    profileId: 1, 
    version: 3
);

if (version3 != null)
{
    // Deserialize snapshot
    var profile = JsonSerializer.Deserialize<MonitoringProfile>(
        version3.ProfileSnapshot
    );
}
```

### 4. Alert Generation (Automatic)

`AlertGenerationService` automatically:
1. Gets latest ProfileHistory for TimeFrame's profile
2. Auto-creates ProfileHistory if missing (handles legacy data)
3. Links `ProfileHistoryId` when creating alerts

```csharp
// Example alert creation logic
var profileHistory = await context.MonitoringProfileHistories
    .Where(h => h.MonitoringProfileId == timeFrame.ProfileId.Value)
    .OrderByDescending(h => h.Version)
    .FirstOrDefaultAsync();

var alert = new MotionAlert
{
    ProfileHistoryId = profileHistory?.Id,
    // ... other properties
};
```

### 5. Tracing Alert to Configuration

```csharp
// Query alert with profile version
var alert = await context.MotionAlerts
    .Include(a => a.ProfileHistory)
    .FirstOrDefaultAsync(a => a.Id == alertId);

if (alert.ProfileHistory != null)
{
    Console.WriteLine($"Alert generated by profile version {alert.ProfileHistory.Version}");
    Console.WriteLine($"Configuration at that time:");
    Console.WriteLine(alert.ProfileHistory.ProfileSnapshot);
}
```

## Workflow

### Profile Update Workflow

```
1. User modifies profile in UI
   ↓
2. Before saving: CreateProfileSnapshotAsync()
   - Loads profile + TimeFrames
   - Serializes to JSON
   - Saves MonitoringProfileHistory record
   - Increments profile.Version
   - Returns history ID
   ↓
3. Apply profile changes and save
   ↓
4. Result:
   - Profile.Version: 1 → 2
   - New record in MonitoringProfileHistories
   - Old version preserved in history
```

### Alert Generation Workflow

```
1. AlertGenerationService runs (every 1 hour)
   ↓
2. For each TimeFrame to check:
   - Get latest ProfileHistory for TimeFrame.ProfileId
   - If no history exists → Auto-create from current profile
   ↓
3. If alert condition met:
   - Create MotionAlert
   - Set ProfileHistoryId = profileHistory.Id
   - Save to database
   ↓
4. Result:
   - Alert linked to exact profile version
   - Can trace back to configuration that generated it
   - Audit trail maintained forever
```

## Database Schema

```sql
-- Add Version to existing profiles
ALTER TABLE MonitoringProfiles ADD Version int NOT NULL DEFAULT 1;
CREATE INDEX IX_MonitoringProfiles_Version ON MonitoringProfiles(Version);

-- Profile history table
CREATE TABLE MonitoringProfileHistories (
    Id int IDENTITY(1,1) PRIMARY KEY,
    MonitoringProfileId int NOT NULL,
    Version int NOT NULL,
    ProfileSnapshot nvarchar(4000) NOT NULL,
    ModifiedBy nvarchar(100) NULL,
    CreatedAt datetime2 NOT NULL,
    ChangeNotes nvarchar(1000) NULL,
    CONSTRAINT FK_MonitoringProfileHistories_MonitoringProfiles 
        FOREIGN KEY (MonitoringProfileId) 
        REFERENCES MonitoringProfiles(Id) 
        ON DELETE CASCADE
);

CREATE INDEX IX_MonitoringProfileHistories_MonitoringProfileId 
    ON MonitoringProfileHistories(MonitoringProfileId);
CREATE INDEX IX_MonitoringProfileHistories_Version 
    ON MonitoringProfileHistories(Version);
CREATE UNIQUE INDEX IX_MonitoringProfileHistories_MonitoringProfileId_Version 
    ON MonitoringProfileHistories(MonitoringProfileId, Version);

-- Link alerts to profile versions
ALTER TABLE MotionAlerts ADD ProfileHistoryId int NULL;
CREATE INDEX IX_MotionAlerts_ProfileHistoryId ON MotionAlerts(ProfileHistoryId);

ALTER TABLE MotionAlerts ADD CONSTRAINT FK_MotionAlerts_MonitoringProfileHistories
    FOREIGN KEY (ProfileHistoryId) 
    REFERENCES MonitoringProfileHistories(Id) 
    ON DELETE SET NULL;

-- Fix cascade conflict (TimeFrame FK)
ALTER TABLE MotionAlerts 
    DROP CONSTRAINT FK_MotionAlerts_TimeFrames_TimeFrameId;

ALTER TABLE MotionAlerts ADD CONSTRAINT FK_MotionAlerts_TimeFrames_TimeFrameId
    FOREIGN KEY (TimeFrameId) 
    REFERENCES TimeFrames(Id) 
    ON DELETE NO ACTION;
```

## ProfileSnapshot Format

```json
{
  "Id": 1,
  "Name": "Standard Monitoring Profile",
  "Description": "Daily monitoring schedule",
  "IsActive": true,
  "Version": 2,
  "CreatedAt": "2025-11-12T10:00:00Z",
  "ModifiedAt": "2025-11-12T14:00:00Z",
  "TimeFrames": [
    {
      "Id": 1,
      "Name": "Morning Shift",
      "StartTime": "06:30:00",
      "EndTime": "14:30:00",
      "DaysOfWeek": "1,2,3,4,5",
      "FrequencyMinutes": 30,
      "IsEnabled": true
    },
    {
      "Id": 2,
      "Name": "Evening Shift",
      "StartTime": "14:30:00",
      "EndTime": "22:30:00",
      "DaysOfWeek": "1,2,3,4,5",
      "FrequencyMinutes": 45,
      "IsEnabled": true
    }
  ]
}
```

## Testing

### Test Profile Versioning

```powershell
# Query current profiles
Invoke-WebRequest -Uri "http://localhost:5000/api/monitoring/profiles" -Method GET

# Update a profile (should create version snapshot)
# Check database:
sqlcmd -S localhost -d StationCheckDb -Q "SELECT * FROM MonitoringProfileHistories"

# Expected: New record with Version = 1 (or next version)
```

### Test Alert with Version

```sql
-- Wait for AlertGenerationService to run (1 hour interval)
-- Or trigger manually via API

-- Check alerts with profile versions
SELECT 
    a.Id,
    a.StationId,
    a.AlertTime,
    a.ProfileHistoryId,
    h.Version as ProfileVersion,
    h.ModifiedBy,
    h.ChangeNotes
FROM MotionAlerts a
LEFT JOIN MonitoringProfileHistories h ON a.ProfileHistoryId = h.Id
ORDER BY a.AlertTime DESC;

-- Expected: ProfileHistoryId populated, can join to get version info
```

### Test Auto-Creation of Missing History

```sql
-- Scenario: Existing profiles with no history
-- When AlertGenerationService runs, it auto-creates ProfileHistory

-- Before: No history
SELECT COUNT(*) FROM MonitoringProfileHistories; -- 0

-- Trigger alert generation (wait 1 hour or restart service)

-- After: History auto-created
SELECT * FROM MonitoringProfileHistories;
-- Should show Version=1 records for each profile used in alerts
```

## API Endpoints (To Be Implemented)

### Get Profile History
```http
GET /api/monitoring/profiles/{id}/history
```

Response:
```json
[
  {
    "id": 1,
    "version": 2,
    "modifiedBy": "admin@company.com",
    "createdAt": "2025-11-12T14:00:00Z",
    "changeNotes": "Updated morning shift time",
    "alertsGenerated": 15
  },
  {
    "id": 2,
    "version": 1,
    "modifiedBy": "system",
    "createdAt": "2025-11-01T10:00:00Z",
    "changeNotes": "Initial version",
    "alertsGenerated": 42
  }
]
```

### Get Specific Version
```http
GET /api/monitoring/profiles/{id}/history/{version}
```

Response:
```json
{
  "id": 1,
  "version": 1,
  "modifiedBy": "system",
  "createdAt": "2025-11-01T10:00:00Z",
  "changeNotes": "Initial version",
  "profileSnapshot": "{...json...}",
  "alertsGenerated": 42
}
```

### Get Alert with Version
```http
GET /api/alerts/{id}?includeProfileVersion=true
```

Response:
```json
{
  "id": 123,
  "stationId": 1,
  "alertTime": "2025-11-12T15:30:00Z",
  "profileHistoryId": 1,
  "profileVersion": {
    "version": 2,
    "modifiedBy": "admin@company.com",
    "createdAt": "2025-11-12T14:00:00Z",
    "profileSnapshot": "{...json...}"
  }
}
```

## UI Components (To Be Implemented)

### Profile History Tab
- Show timeline of all versions
- Display version number, date, modified by
- Show diff between versions
- List alerts generated by each version
- Button to view full snapshot
- Optional: Revert to previous version

### Alert Detail Page
- Show profile version that generated alert
- Link to view that version's configuration
- Show diff between current and version at alert time
- Helps understand why alert was generated

## Best Practices

1. **Always create snapshot before modifying profile**
   ```csharp
   // GOOD
   await _versioningService.CreateProfileSnapshotAsync(profileId, user, notes);
   // Then modify profile...
   
   // BAD - no history
   // Directly modify profile without snapshot
   ```

2. **Add meaningful change notes**
   ```csharp
   // GOOD
   "Updated morning shift frequency from 30 to 45 minutes"
   
   // BAD
   "Profile updated"
   ```

3. **Include version info in logs**
   ```csharp
   _logger.LogInformation(
       "Alert generated for station {StationId} using profile version {Version}",
       stationId, 
       profileHistory.Version
   );
   ```

4. **Monitor ProfileSnapshot size**
   - Max 4000 characters in database
   - If profiles grow large, consider separate storage
   - Compress JSON if needed

5. **Handle missing ProfileHistory gracefully**
   ```csharp
   if (alert.ProfileHistory == null)
   {
       // Legacy alert without version
       // Still display alert, just note "Version not tracked"
   }
   ```

## Troubleshooting

### Problem: No history records created

**Check:**
```sql
SELECT * FROM MonitoringProfileHistories;
```

**Solution:**
- Ensure ProfileVersioningService is registered in Program.cs
- Verify CreateProfileSnapshotAsync is called before profile updates
- Check logs for serialization errors

### Problem: Alerts have NULL ProfileHistoryId

**Possible Causes:**
1. AlertGenerationService couldn't find ProfileHistory
2. TimeFrame has NULL ProfileId
3. Profile was deleted (CASCADE delete removed history)

**Solution:**
```sql
-- Check TimeFrame configuration
SELECT tf.Id, tf.ProfileId, tf.Name 
FROM TimeFrames tf
WHERE tf.ProfileId IS NULL;

-- Check if ProfileHistory exists for profiles
SELECT p.Id, p.Name, COUNT(h.Id) as VersionCount
FROM MonitoringProfiles p
LEFT JOIN MonitoringProfileHistories h ON p.Id = h.MonitoringProfileId
GROUP BY p.Id, p.Name;
```

### Problem: Cascade DELETE conflict error

**Error:**
```
Introducing FOREIGN KEY constraint may cause cycles or multiple cascade paths
```

**Cause:** Multiple cascade paths from MonitoringProfile:
- Profile → TimeFrame → Alert (CASCADE)
- Profile → ProfileHistory → Alert (SET NULL)

**Solution:** Use NO ACTION for TimeFrame FK (already fixed in migration)

## Migration History

- **20251112141657_AddProfileVersioningAndHistory**
  - Added Version to MonitoringProfiles (default 1)
  - Created MonitoringProfileHistories table
  - Added ProfileHistoryId to MotionAlerts
  - Created 6 indexes for performance
  - Fixed cascade conflict with TimeFrame FK

## Related Files

- `Models/MonitoringProfile.cs` - Version field
- `Models/MonitoringProfileHistory.cs` - History entity
- `Models/MotionAlert.cs` - ProfileHistoryId link
- `Services/ProfileVersioningService.cs` - Core versioning logic
- `Interfaces/IProfileVersioningService.cs` - Service contract
- `BackgroundServices/AlertGenerationService.cs` - Auto-link to versions
- `Data/ApplicationDbContext.cs` - EF configuration
- `Migrations/20251112141657_AddProfileVersioningAndHistory.cs` - Database schema

## Future Enhancements

1. **Profile Diff Viewer**
   - Show side-by-side comparison of two versions
   - Highlight what changed

2. **Revert to Previous Version**
   - Create new version from old snapshot
   - Preserve history chain

3. **Profile Change Notifications**
   - Email admins when profiles are modified
   - Include version diff in email

4. **Version Approval Workflow**
   - Changes in draft mode until approved
   - Only approved versions used for alerts

5. **Compression for Large Profiles**
   - Compress JSON before storing
   - Decompress when retrieving

6. **History Retention Policy**
   - Archive old versions after N months
   - Keep summary metrics only
